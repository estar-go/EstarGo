# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.8
#
# <auto-generated>
#
# Generated from file `Proto.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module GoKu
_M_GoKu = Ice.openModule('GoKu')
__name__ = 'GoKu'

if '_t_RequestBatch' not in _M_GoKu.__dict__:
    _M_GoKu._t_RequestBatch = IcePy.defineSequence('::GoKu::RequestBatch', (), IcePy._t_string)

if 'MoveProb' not in _M_GoKu.__dict__:
    _M_GoKu.MoveProb = Ice.createTempClass()
    class MoveProb(object):
        def __init__(self, pos=0, prob=0.0):
            self.pos = pos
            self.prob = prob

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_GoKu.MoveProb):
                return NotImplemented
            else:
                if self.pos != other.pos:
                    return False
                if self.prob != other.prob:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_GoKu._t_MoveProb)

        __repr__ = __str__

    _M_GoKu._t_MoveProb = IcePy.defineStruct('::GoKu::MoveProb', MoveProb, (), (
        ('pos', (), IcePy._t_int),
        ('prob', (), IcePy._t_float)
    ))

    _M_GoKu.MoveProb = MoveProb
    del MoveProb

if '_t_PolicyReply' not in _M_GoKu.__dict__:
    _M_GoKu._t_PolicyReply = IcePy.defineSequence('::GoKu::PolicyReply', (), _M_GoKu._t_MoveProb)

if 'Reply' not in _M_GoKu.__dict__:
    _M_GoKu.Reply = Ice.createTempClass()
    class Reply(object):
        def __init__(self, p=None, v=0.0):
            self.p = p
            self.v = v

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_GoKu.Reply):
                return NotImplemented
            else:
                if self.p != other.p:
                    return False
                if self.v != other.v:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_GoKu._t_Reply)

        __repr__ = __str__

    _M_GoKu._t_Reply = IcePy.defineStruct('::GoKu::Reply', Reply, (), (
        ('p', (), _M_GoKu._t_PolicyReply),
        ('v', (), IcePy._t_float)
    ))

    _M_GoKu.Reply = Reply
    del Reply

if '_t_ReplyBatch' not in _M_GoKu.__dict__:
    _M_GoKu._t_ReplyBatch = IcePy.defineSequence('::GoKu::ReplyBatch', (), _M_GoKu._t_Reply)

_M_GoKu._t_InterfaceEval = IcePy.defineValue('::GoKu::InterfaceEval', Ice.Value, -1, (), False, True, None, ())

if 'InterfaceEvalPrx' not in _M_GoKu.__dict__:
    _M_GoKu.InterfaceEvalPrx = Ice.createTempClass()
    class InterfaceEvalPrx(Ice.ObjectPrx):

        def evaluate(self, req, context=None):
            return _M_GoKu.InterfaceEval._op_evaluate.invoke(self, ((req, ), context))

        def evaluateAsync(self, req, context=None):
            return _M_GoKu.InterfaceEval._op_evaluate.invokeAsync(self, ((req, ), context))

        def begin_evaluate(self, req, _response=None, _ex=None, _sent=None, context=None):
            return _M_GoKu.InterfaceEval._op_evaluate.begin(self, ((req, ), _response, _ex, _sent, context))

        def end_evaluate(self, _r):
            return _M_GoKu.InterfaceEval._op_evaluate.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_GoKu.InterfaceEvalPrx.ice_checkedCast(proxy, '::GoKu::InterfaceEval', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_GoKu.InterfaceEvalPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::GoKu::InterfaceEval'
    _M_GoKu._t_InterfaceEvalPrx = IcePy.defineProxy('::GoKu::InterfaceEval', InterfaceEvalPrx)

    _M_GoKu.InterfaceEvalPrx = InterfaceEvalPrx
    del InterfaceEvalPrx

    _M_GoKu.InterfaceEval = Ice.createTempClass()
    class InterfaceEval(Ice.Object):

        def ice_ids(self, current=None):
            return ('::GoKu::InterfaceEval', '::Ice::Object')

        def ice_id(self, current=None):
            return '::GoKu::InterfaceEval'

        @staticmethod
        def ice_staticId():
            return '::GoKu::InterfaceEval'

        def evaluate(self, req, current=None):
            raise NotImplementedError("servant method 'evaluate' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_GoKu._t_InterfaceEvalDisp)

        __repr__ = __str__

    _M_GoKu._t_InterfaceEvalDisp = IcePy.defineClass('::GoKu::InterfaceEval', InterfaceEval, (), None, ())
    InterfaceEval._ice_type = _M_GoKu._t_InterfaceEvalDisp

    InterfaceEval._op_evaluate = IcePy.Operation('evaluate', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), _M_GoKu._t_RequestBatch, False, 0),), (((), _M_GoKu._t_ReplyBatch, False, 0),), None, ())

    _M_GoKu.InterfaceEval = InterfaceEval
    del InterfaceEval

# End of module GoKu
